프로젝트 코딩 컨벤션 및 디자인 원칙 (React & JavaScript)
1. 일반 원칙 (General Principles)
1.1 SOLID 원칙 준수
단일 책임 원칙 (SRP): 컴포넌트, 커스텀 훅, 함수는 오직 하나의 기능적 책임만 가져야 합니다.
개방-폐쇄 원칙 (OCP): 기존 코드를 수정하지 않고도 Props나 컴포넌트 합성을 통해 기능을 확장할 수 있도록 설계해야 합니다.
인터페이스 분리 원칙 (ISP): 컴포넌트가 필요 이상의 props를 받지 않도록 명확하게 분리하고, PropTypes를 사용하여 인터페이스를 명시적으로 정의해야 합니다.
의존성 역전 원칙 (DIP): 고수준 컴포넌트(페이지)는 저수준 UI 컴포넌트(버튼, 인풋)에 직접 의존하기보다, props라는 추상화된 인터페이스에 의존해야 합니다.
1.2 클린 코드 (Clean Code)
명확한 네이밍: 변수, 함수, 컴포넌트 이름은 역할과 의도를 명확하게 드러내도록 작성해야 합니다. (아래 1.3 네이밍 컨벤션 참고)
함수 분리: 함수는 한 가지 일만 하도록 작게 만들고, 복잡한 로직은 커스텀 훅이나 유틸리티 함수로 분리하여 재사용성을 높여야 합니다.
상수 관리:
컴포넌트 내부에서만 사용하는 상수는 파일 상단에 정의합니다.
여러 파일에서 공통으로 사용되는 전역 상수는 src/constants 폴더에서 관리합니다.
1.3 네이밍 컨벤션 (Naming Convention)
컴포넌트명: PascalCase (예: UserCard)
변수/함수명: camelCase (예: handleClick)
상수: UPPER_SNAKE_CASE (예: DEFAULT_LIMIT)
파일/폴더명: PascalCase (예: ProfilePage.jsx)
이벤트 핸들러: handle + 동작 + 대상 명명법을 사용합니다. (예: handleClickButton)
상태(State): Boolean 값은 is 또는 has 접두사를 사용합니다. (예: isLoading, hasError)
스타일 클래스명: camelCase 또는 BEM을 따릅니다.
2. React 개발 가이드라인
2.1 아키텍처 및 컴포넌트 설계
컴포넌트 구조: 렌더링과 관련 없는 로직은 return 문 위에 작성하여 로직과 JSX를 분리해야 합니다. 컴포넌트가 비대해지거나(예: 200줄 이상) 여러 역할을 수행하면 의미 있는 단위로 분리해야 합니다.
Props 설계:
prop-types 라이브러리를 사용하여 각 컴포넌트가 받는 props의 타입과 필수 여부를 명확히 정의해야 합니다.
3개 이상의 Props를 전달할 경우, 객체로 묶어 스프레드 연산자로 전달하는 것을 고려합니다.
상태 관리: 지역 상태는 useState, 전역 상태는 Zustand나 Redux Toolkit 사용을 원칙으로 합니다. 간단한 공유는 Context API를 고려할 수 있습니다.
JSX 작성 규칙: 불필요한 div 래핑 대신 <> (Fragment)를 사용하여 DOM 트리를 간결하게 유지해야 합니다.
관심사의 분리: 비즈니스 로직 및 API 호출 로직은 커스텀 훅으로 분리하여 재사용성을 높이고 컴포넌트는 UI 렌더링에 집중시켜야 합니다.
2.2 API 연동 및 데이터 처리
API 클라이언트 중앙 관리: axios 인스턴스를 생성하여 baseURL, 인터셉터 등 API 관련 설정을 한 곳에서 관리해야 합니다.
서버 상태 관리: React-Query(TanStack Query)나 SWR을 사용하여 API 데이터 fetching, 캐싱, 로딩/에러 상태를 선언적으로 관리해야 합니다.
API 로직 추상화: 데이터 fetching 로직은 useFetchUsers와 같은 커스텀 훅 형태로 분리하여 재사용해야 합니다.
2.3 성능 최적화
렌더링 최적화: React.memo를 사용하여 불필요한 컴포넌트 리렌더링을 방지해야 합니다.
함수 메모이제이션: 자식 컴포넌트에 함수를 props로 전달할 때는 useCallback을 사용하여 불필요한 함수 재생성을 방지해야 합니다.
값 메모이제이션: 복잡하고 비용이 큰 연산의 결과값은 useMemo를 사용하여 계산 결과를 캐싱해야 합니다.
코드 스플리팅: React.lazy와 Suspense를 사용하여 라우트(페이지) 단위로 코드를 분할하고 초기 로딩 성능을 향상시켜야 합니다.
2.4 오류 처리 및 보안
에러 바운더리: 렌더링 단계에서 발생하는 오류가 앱 전체를 중단시키지 않도록, 주요 컴포넌트 트리를 에러 바운더리로 감싸 안정성을 높여야 합니다.
환경 변수 관리: 민감 정보는 .env 파일에 REACT_APP_ 접두사를 붙여 관리하고, 소스 코드에 직접 노출하지 않아야 합니다.
XSS 방지: 보안상 위험한 dangerouslySetInnerHTML prop은 절대 사용해서는 안 됩니다.
2.5 테스트
테스트 환경: Jest와 React Testing Library를 사용하여 사용자 관점의 테스트를 작성해야 합니다.
테스트 대상: 커스텀 훅, 유틸리티 함수, 핵심 비즈니스 로직을 포함하는 컴포넌트를 우선적으로 테스트합니다. API 호출은 MSW로 모킹합니다.
테스트 코드 명확성: given-when-then(준비-실행-검증) 패턴을 사용하여 테스트의 의도를 명확하게 작성해야 합니다.